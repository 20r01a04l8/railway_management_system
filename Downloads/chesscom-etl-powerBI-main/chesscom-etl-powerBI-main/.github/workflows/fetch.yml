name: Chess.com Daily Fetch → Google Sheets

on:
  schedule:
    - cron: '0 2 * * *'       # daily at 02:00 UTC (adjust as needed)
  workflow_dispatch:
    inputs:
      usernames:
        description: 'Comma-separated chess.com usernames (override secret CHESS_USERNAMES)'
        required: false
        default: ''

permissions:
  contents: write

concurrency:
  group: chess-fetch
  cancel-in-progress: true

jobs:
  fetch-and-save:
    runs-on: ubuntu-latest
    timeout-minutes: 30

    env:
      # CLI input or repository secret
      CHESS_USERNAMES: ${{ github.event.inputs.usernames || secrets.CHESS_USERNAMES || '' }}
      SHEET_ID: ${{ secrets.SHEET_ID || '' }}
      SHEET_NAME_PREFIX: ${{ secrets.SHEET_NAME_PREFIX || '' }}
      MAKE_USER_AGENT: ${{ secrets.MAKE_USER_AGENT || 'ChessAnalytics/1.0 (+your-email@example.com)' }}
      CHESS_REQUEST_DELAY: ${{ secrets.CHESS_REQUEST_DELAY || '1.0' }}
      CHESS_MAX_RETRIES: ${{ secrets.CHESS_MAX_RETRIES || '3' }}
      STATE_FILE: ${{ secrets.STATE_FILE || 'state.json' }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          persist-credentials: true

      - name: Set up Python 3.10
        uses: actions/setup-python@v4
        with:
          python-version: '3.13'

      - name: Cache pip
        uses: actions/cache@v4
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}
          restore-keys: |
            ${{ runner.os }}-pip-

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install requests gspread google-auth

      - name: Ensure STATE_FILE exists (initial)
        run: |
          if [ ! -f "${{ env.STATE_FILE }}" ]; then
            printf "{}" > "${{ env.STATE_FILE }}"
            git add "${{ env.STATE_FILE }}" || true
            git commit -m "chore(state): add initial ${STATE_FILE}" || true
            git push origin HEAD || true
          fi

      - name: Debug - check secret presence (safe)
        shell: bash
        run: |
          if [ -z "${{ secrets.GSPREAD_SERVICE_ACCOUNT_JSON_B64 }}" ]; then
            echo "DEBUG: secret GSPREAD_SERVICE_ACCOUNT_JSON_B64 is EMPTY"
            exit 1
          fi
          len=$(printf '%s' "${{ secrets.GSPREAD_SERVICE_ACCOUNT_JSON_B64 }}" | wc -c)
          echo "DEBUG: secret GSPREAD_SERVICE_ACCOUNT_JSON_B64 exists; length=$len"

      - name: Decode service account secret to file
        shell: bash
        run: |
          if [ -z "${{ secrets.GSPREAD_SERVICE_ACCOUNT_JSON_B64 }}" ]; then
            echo "GSPREAD_SERVICE_ACCOUNT_JSON_B64 is empty - ensure secret is set (not available to fork PRs)."
            exit 1
          fi
          printf '%s' "${{ secrets.GSPREAD_SERVICE_ACCOUNT_JSON_B64 }}" | base64 --decode > sa.json
          if ! grep -q '"client_email"' sa.json; then
            echo "Decoded file does not look like a service account JSON (missing client_email)."
            exit 1
          fi
          echo "Decoded service account key to sa.json (runner-only)."

      - name: Unmark last processed archive (auto)
        # Removes the last element from each user's processed_archives in state.json so the latest archive is re-processed
        shell: bash
        run: |
          python - <<'PY'
          import os, json, sys
          path = os.environ.get("STATE_FILE", "state.json")
          if not os.path.exists(path):
            print(f"State file not found ({path}) — nothing to unmark.")
            sys.exit(0)
          try:
            with open(path, "r", encoding="utf-8") as f:
              data = json.load(f) or {}
          except Exception as e:
            print(f"Failed to read state file {path}: {e}")
            sys.exit(0)
          changed = False
          for user, obj in list(data.items()):
            pa = obj.get("processed_archives", [])
            if isinstance(pa, list) and pa:
              removed = pa.pop()  # remove last processed archive
              print(f"User '{user}': removed processed archive -> {removed}")
              obj["processed_archives"] = pa
              changed = True
            else:
              print(f"User '{user}': no processed_archives to remove")
          if changed:
            try:
              with open(path, "w", encoding="utf-8") as f:
                json.dump(data, f, indent=2, ensure_ascii=False)
              print(f"Updated {path} (last processed archive removed for some users).")
            except Exception as e:
              print(f"Failed to write updated state file: {e}")
              sys.exit(1)
          else:
            print("No changes made to state file.")
          PY

      - name: Run fetch_and_post.py (writes to Google Sheets)
        run: |
          if [ -n "${{ github.event.inputs.usernames }}" ]; then
            python fetch_and_post.py "${{ github.event.inputs.usernames }}"
          else
            python fetch_and_post.py ""
          fi
        env:
          GSPREAD_SA_JSON_PATH: ./sa.json
          SHEET_ID: ${{ env.SHEET_ID }}
          SHEET_NAME_PREFIX: ${{ env.SHEET_NAME_PREFIX }}
          MAKE_USER_AGENT: ${{ env.MAKE_USER_AGENT }}
          CHESS_REQUEST_DELAY: ${{ env.CHESS_REQUEST_DELAY }}
          CHESS_MAX_RETRIES: ${{ env.CHESS_MAX_RETRIES }}
          STATE_FILE: ${{ env.STATE_FILE }}
          CHESS_USERNAMES: ${{ env.CHESS_USERNAMES }}

      - name: Commit and push updated state.json and outputs (if changed)
        shell: bash
        env:
          GIT_BRANCH: ${{ github.ref_name || 'main' }}
        run: |
          set -euo pipefail

          git config user.name "github-actions[bot]" || true
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com" || true

          # Stage files (only those we intend to persist)
          git add "${{ env.STATE_FILE }}" outputs || true

          # Nothing to commit?
          if git diff --cached --quiet; then
            echo "No changes to commit"
            exit 0
          fi

          git commit -m "chore: update state and outputs [ci skip]" || true

          # Try to rebase with remote to avoid non-fast-forward
          echo "Attempting to pull --rebase from origin/${GIT_BRANCH} to avoid non-fast-forward push..."
          set +e
          git fetch origin "${GIT_BRANCH}"
          pull_ok=0
          git pull --rebase --autostash origin "${GIT_BRANCH}"
          if [ $? -eq 0 ]; then
            pull_ok=1
          fi
          set -e

          if [ "$pull_ok" -ne 1 ]; then
            echo "Warning: git pull --rebase failed. Skipping push to avoid non-fast-forward or conflicts."
            echo "==== git status ===="
            git status --porcelain --branch || true
            echo "==== git log (local vs origin) ===="
            git --no-pager log --oneline --decorate --graph --all -n 20 || true
            exit 0
          fi

          # Now push
          echo "Pushing changes to origin/${GIT_BRANCH}..."
          if git push origin "HEAD:${GIT_BRANCH}"; then
            echo "Push succeeded."
          else
            echo "Push failed (non-fast-forward or permission). Not forcing a push for safety."
            git status --porcelain --branch || true
            exit 0
          fi
